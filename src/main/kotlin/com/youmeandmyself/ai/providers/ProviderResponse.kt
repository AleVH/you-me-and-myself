package com.youmeandmyself.ai.providers

import com.youmeandmyself.ai.providers.parsing.ParsedResponse

/**
 * Raw result from an AI provider HTTP call.
 *
 * ## Why This Exists
 *
 * Before this refactoring, [GenericLlmProvider] did HTTP + storage writes + token indexing +
 * assistant text caching + derived metadata extraction + IDE context storage — all inside
 * what should have been an HTTP client. This class represents the clean boundary:
 * the provider does HTTP and parsing, nothing else.
 *
 * ## What the Provider Does
 *
 * 1. Build the HTTP request (protocol-specific: OpenAI, Gemini, Custom)
 * 2. Send it and receive the raw response
 * 3. Parse it via [ResponseParser] to extract content, tokens, metadata
 * 4. Return this [ProviderResponse] — done.
 *
 * ## What the Provider Does NOT Do
 *
 * - Save to storage (orchestrator does this)
 * - Index tokens (orchestrator does this)
 * - Cache assistant text (orchestrator does this)
 * - Extract derived metadata (orchestrator does this)
 * - Capture IDE context (orchestrator does this before calling provider)
 *
 * ## Exchange ID
 *
 * The provider generates the exchange ID because it's needed during parsing
 * (ParsedResponse carries it). The orchestrator uses this ID for all subsequent
 * storage operations. This avoids the orchestrator having to inject an ID into
 * the provider call.
 *
 * @property parsed The parsed response with extracted content, error info, and parse metadata.
 *                  This is the same ParsedResponse that existed before, just no longer coupled
 *                  to storage writes.
 * @property rawJson The raw JSON string from the HTTP response. Preserved verbatim for storage.
 *                   Null only if the request failed before receiving any response body.
 * @property httpStatus The HTTP status code. Null if the request failed at the network level
 *                      (DNS failure, timeout, connection refused, etc.)
 * @property prompt The original prompt that was sent. Stored alongside the response so the
 *                  orchestrator can persist the complete exchange without needing to track
 *                  what was sent separately.
 */
data class ProviderResponse(
    val parsed: ParsedResponse,
    val rawJson: String?,
    val httpStatus: Int?,
    val prompt: String
) {
    /**
     * Convenience accessor: the unique ID for this exchange.
     *
     * Generated by the provider during parsing. Used by the orchestrator
     * to link all storage operations (save, token index, assistant text cache,
     * derived metadata, IDE context) to the same exchange.
     */
    val exchangeId: String get() = parsed.exchangeId

    /**
     * Convenience accessor: whether the parsed response indicates an error.
     *
     * True for: HTTP errors (4xx, 5xx), network failures, parse failures,
     * and provider-reported errors (rate limits, content filters, etc.)
     */
    val isError: Boolean get() = parsed.isError

    /**
     * Convenience accessor: the display-ready text extracted from the response.
     *
     * For successful responses, this is the AI-generated content.
     * For errors, this is a human-readable error message.
     */
    val displayText: String get() = parsed.displayText
}